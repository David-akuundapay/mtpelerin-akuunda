<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Akuunda Pay - Exchange</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: url('https://raw.githubusercontent.com/David-akuundapay/mtpelerin-akuunda/main/mtpelerin-akuunda/images/brand-hero.jpg') no-repeat center center fixed;
      background-size: cover;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      flex-direction: column;
    }
    h1 {
      color: white;
      margin-bottom: 20px;
      font-size: 2.2rem;
      text-shadow: 1px 1px 4px rgba(0,0,0,0.6);
    }
    iframe {
      width: 420px;
      height: 700px;
      border: none;
      border-radius: 15px;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
      background: white;
    }
  </style>
</head>
<body>
  <h1>Akuunda Pay</h1>
  <iframe
    id="akuunda-widget"
    allow="usb; ethereum; clipboard-write; payment;"
    title="Akuunda Exchange Widget"
  ></iframe>

  <script>
    const CONFIG = {
      BACKEND_URL: 'https://mtpay.akuunda-pay.io/api/mtpelerin',
      API_TOKEN: '1c7a15d7-7243-4a77-a04e-c2b74061fa88'
    };

    const url = new URL(window.location.href);
    const params = url.searchParams;

    let tab = params.get("tab");
    if (!["buy", "sell"].includes(tab)) {
      document.body.innerHTML = "<h2 style='color:white;text-shadow:1px 1px 4px black;'>Paramètre invalide : utilisez tab=buy ou tab=sell</h2>";
    } else {
      const baseUrl = "https://widget.mtpelerin.com/";
      const widgetParams = new URLSearchParams({
        _ctkn: CONFIG.API_TOKEN,
        tab: tab,
        hideTabs: "true",
        display: "direct",
        lang: "fr",
        primaryColor: "F88809",
        primaryTextColor: "FFFFFF",
        secondaryColor: "F88809",
        background: "FFFFFF",
        successColor: "F88809",
        warningColor: "F88809",
        infoColor: "F88809",
        net: params.get("net") || "matic_mainnet",
        addr: params.get("addr") || "",
        code: params.get("code") || "",
        hash: params.get("hash") || ""
      });

      if (tab === "sell") {
        widgetParams.set("ssc", params.get("ssc") || "USDT");
        widgetParams.set("sdc", params.get("sdc") || "EUR");
        widgetParams.set("ssa", params.get("ssa") || "100");
        widgetParams.set("snet", params.get("snet") || "matic_mainnet");
      } else {
        widgetParams.set("bsc", params.get("bsc") || "EUR");
        widgetParams.set("bdc", params.get("bdc") || "USDT");
        widgetParams.set("bsa", params.get("bsa") || "100");
        widgetParams.set("dnet", params.get("dnet") || "matic_mainnet");
        widgetParams.set("pm", params.get("pm") || "card");
      }

      const finalUrl = `${baseUrl}?${widgetParams.toString()}`;
      document.getElementById("akuunda-widget").src = finalUrl;
    }

    window.addEventListener("message", (event) => {
      if (!event.origin.includes("mtpelerin.com")) return;

      try {
        const message = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
        if (!message?.type) return;

        switch (message.type) {
          case "orderCreated":
            sendToBackend("order/created", {
              orderId: message.data.id,
              orderType: message.data.type,
              currencyIn: message.data.currencyIn,
              currencyOut: message.data.currencyOut,
              amountIn: message.data.valueIn,
              amountOut: message.data.valueOut,
              depositAddress: message.data.cryptoAddress || message.data.offRampAddress,
              network: message.data.network,
              timestamp: new Date().toISOString(),
              source: "akuunda_pay_widget"
            });
            break;
          case "paymentSubmitted":
            sendToBackend("payment/submitted", {
              orderId: message.data.orderId,
              paymentType: message.data.paymentType,
              transactionHash: message.data.transactionHash,
              timestamp: new Date().toISOString()
            });
            break;
          case "orderCompleted":
            sendToBackend("order/completed", {
              orderId: message.data.id,
              status: "completed",
              finalAmount: message.data.finalAmount,
              timestamp: new Date().toISOString()
            });
            break;
          case "orderFailed":
            sendToBackend("order/failed", {
              orderId: message.data.id,
              status: "failed",
              error: message.data.error,
              timestamp: new Date().toISOString()
            });
            break;
        }
      } catch (error) {
        console.error("Widget message error", error);
      }
    });

    async function sendToBackend(endpoint, data) {
      try {
        const response = await fetch(`${CONFIG.BACKEND_URL}/${endpoint}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data)
        });
        if (response.ok) {
          console.log(`✅ ${endpoint} sent successfully`);
        }
      } catch (e) {
        console.warn("⚠️ Backend unreachable", e);
      }
    }
  </script>
</body>
</html>
